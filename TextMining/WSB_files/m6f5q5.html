<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><style type="text/css">body, object, embed, div, span, p { margin: 0; padding: 0; } iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><script charset="utf-8" src="m6f5q5_data/horizon_tweet.js"></script></head><body style="margin: 0px;"><div class="twitter-tweet twitter-tweet-rendered" style="display: flex; max-width: 550px; width: 100%; margin: 0px;"><iframe id="twitter-widget-0" scrolling="no" allowtransparency="true" allowfullscreen="true" class="" style="position: static; visibility: visible; width: 350px; height: 250px; display: block; flex-grow: 1;" title="Twitter Tweet" src="m6f5q5_data/Tweet.html" data-tweet-id="1371883976386830341" frameborder="0"></iframe></div><script async="async" src="m6f5q5_data/widgets.js" charset="utf-8"></script><script type="text/javascript">/** * NOTE(knewkirk, 4/29/2020): Twitter is currently in the process of updating their * embeds. This means that we need to be ready, and support both this old and new code. * Most logic will remain the same - notable changes include the `isRendered` flag * for better deletion detection (we can't query the iframe DOM), and simpler styles * (they use obfuscated class names) */ window.onload = function() { twttr.ready(function(twttr) { var TWEET_SELECTOR = '.twitter-tweet'; var MAX_RETRIES = 2; var isRendered = false; var measureTimeoutId = 0; /** * We always send the latest height measurement, even if the result is 0, * so the client is always up to date and can make the final decision for * what to display and when to ask this script to remeasure. * We also need to include the post id here, since there's no way for the * client to know which iframe the message comes from. The only alternative * is for the frontend to query for all of the iframe elements each time * a message comes in and compare them to the message source. * We don't specify a domain because this is used for both prod and staging, * and there isn't really any sensitive data here. */ function sendMessage(height, isDeleted) { window.parent.postMessage({ action: 'tweet-measured', height: height, isDeleted: isDeleted, id36: 'm6f5q5' }, '*'); } /** * This is the main measuring logic - if it hasn't rendered * or no element with the `twitter-tweet` class, we should try to measure again * with a little bit of backing off. */ function measure(times) { var widgetEl = document.querySelector(TWEET_SELECTOR); if (!widgetEl || !isRendered) { if (times >MAX_RETRIES) { sendMessage(0, true); } else { if (measureTimeoutId) { clearTimeout(measureTimeoutId); } measureTimeoutId = setTimeout( function() { measure(times + 1); }, 1000 * (times + 1) ); } return; } var height = widgetEl.clientHeight; /** * Not supported by IE/Edge, but that's ok, they'll just get an empty post * with a link to the tweet. * Not supported in the new twitter embed */ var sandboxRootEl = widgetEl.shadowRoot && widgetEl.shadowRoot.querySelector('.SandboxRoot'); if (sandboxRootEl && sandboxRootEl.childElementCount === 0 || height === 0) { if (times< MAX_RETRIES) { if (measureTimeoutId) { clearTimeout(measureTimeoutId); } measureTimeoutId = setTimeout(function() { measure(times + 1); }, 1000 * (times + 1)); } else { sendMessage(0, true); } } else { sendMessage(height, false); } } /** * This handles messages coming back from the client when the iframe should * try and measure itself again - the user may have scrolled past the iframe * as it was trying to render the first time. So we try and remeasure when it * comes back into view. * We can't use the config value for origin because production r2 is used * for both staging and production desktop */ window.addEventListener('message', function(m) { if ( m.data === 'twitter-measure-requested' && ( m.origin.indexOf('reddit.local') >0 || m.origin.indexOf('snooguts.net') >0 || m.origin.indexOf('reddit.com') >0 ) ) { measure(0); } }); function init(event) { isRendered = true; var widgetEl = event.target || document.querySelector(TWEET_SELECTOR); /** * -------------------- Old Styles Implementation START -------------------- * * These styles are inline on the<twitter-widget/>that originally * gets rendered, and we _really_ don't need any extra margins. And * their API doesn't really even respect the width parameter we send it. */ if (widgetEl && widgetEl.shadowRoot) { widgetEl.style.marginTop = 0; widgetEl.style.marginBottom = 0; widgetEl.style.width = '350px'; widgetEl.style.height = '100%'; var styleEl = document.createElement('style'); styleEl.type = 'text/css'; /** * There are a few tweaks to the inner tweet styles we need to make: * - hide the bottom 'See more tweets from X' >product ask * - fix the border around bottom since the CTA is gone * - make sure that the added borders respect nightmode */ styleEl.innerHTML = " a.CallToAction { display: none; } .EmbeddedTweet { margin: 0; } .EmbeddedTweet--cta.EmbeddedTweet--mediaForward .EmbeddedTweet-tweet { border-bottom: 1px solid #66757f; border-radius: 0 0 5px 5px; } .EmbeddedTweet--cta.EmbeddedTweet--mediaForward .MediaCard.MediaCard--mediaForward.cards-multimedia { border: 1px solid #66757f; border-radius: 5px 5px 0 0; } .EmbeddedTweet--cta.EmbeddedTweet--mediaForward:hover .EmbeddedTweet-tweet, .EmbeddedTweet--cta.EmbeddedTweet--mediaForward:hover .MediaCard.MediaCard--mediaForward.cards-multimedia { border-color: #8899a6; } "; widgetEl.shadowRoot.appendChild(styleEl); } /* -------------------- Old Styles Implementation END ----------------------- */ /* ------------------------New Implementation START -------------------------- */ if (widgetEl && widgetEl.parentElement) { widgetEl.style.margin = 0; widgetEl.parentElement.style.margin = 0; } /* ------------------------New Implementation END -------------------------- */ /** * ----------------- FOR BOTH OLD AND NEW ------------------------------- * * Wait to make the first measurement after 500ms * - did some manual testing and that seemed like the best tradeoff between * waiting on the client and actually having a measurement to send back. */ if (measureTimeoutId) { clearTimeout(measureTimeoutId); } measureTimeoutId = setTimeout(function() { measure(0); }, 500); } twttr.events.bind('rendered', init); twttr.events.bind('resize', init); }); };</script><script>var AUTHORIZED_DOMAINS = ["https://*.reddit.com", "https://reddit.com", "https://*.snooguts.net", "https://localhost", "http://localhost", "https://reddit.local"];</script><script type="text/javascript" src="m6f5q5_data/media-embed.js" async=""></script><iframe scrolling="no" allowtransparency="true" src="m6f5q5_data/widget_iframe.html" title="Twitter settings iframe" style="display: none;" frameborder="0"></iframe><iframe id="rufous-sandbox" scrolling="no" allowtransparency="true" allowfullscreen="true" style="position: absolute; visibility: hidden; display: none; width: 0px; height: 0px; padding: 0px; border: medium none;" title="Twitter analytics iframe" frameborder="0"></iframe></body></html>